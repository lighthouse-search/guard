*Guard is in alpha release, please visit [TODO](#whats-on-the-todo-list) to see what's happening before beta*

# Why
Before Guard, when I built apps, I had a Node.JS script handle [Subrequest authentication](https://docs.nginx.com/nginx/admin-guide/security-controls/configuring-subrequest-authentication/) requests from NGINX. As I deployed more apps, IF statements enforcing authentication policy became more complex, new authentication protocols needed to get integrated per-project, login pages needed new code and designs to support different projects - all of this creates potential security gaps and is overall a pain.
I built Guard to streamline this process and make it available for everyone.
Also I'm concerned how a handful of companies like Microsoft, Google and Okta/Auth0 control large portions of the internet's authentication, including authentication to sensitive dashboards. If any of those services were breached, or used for [surveillance](https://www.theguardian.com/world/2013/jun/06/us-tech-giants-nsa-data), the internet's independence would be severely undermined.

Guard's core mission is being able to:
- Run anywhere, including with or without a database.
- Act as an authentication server for all major authentication protocols (OAuth, SAML, Kerberos)
- Act as an app's authentication (e.g. library support in major programming languages, or reverse-proxying requests to an app's webserver to insert user information in request information)
- Authenticate reverse proxies (e.g. [Guard + NGINX](#guard--nginx))

# Example
Guard allows you to create great, styled, authentication with a simple configuration.
![Screenshot 2025-06-22 230233](https://github.com/user-attachments/assets/40fe9c2f-0f9c-449e-a637-81ec4a89796d)


```
[features]
reverse_proxy_authentication = true

[reverse_proxy_authentication.config]
header = "x-original-url"

[frontend.metadata]
instance_hostname = "guard.example.com"
alias = "ACME"
public_description = "You're accessing sensitive information. Please login."
image = "https://images.unsplash.com/photo-1565799557186-1abfed8a31e5?q=80&w=3087&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D"
domain_placeholder="example.com"
username_placeholder="username"

[database.mysql]
username = "example-user"
password_env = "example_user_mysql_password"
hostname = "internal-mariadb-main-service.sql.svc.cluster.local"
port = 3306
database = "guard"

[smtp]
host="smtp.sendgrid.net"
port=587
username="apikey"
from_alias="Guard"
from_header="noreply@paperplane.example.com"
reply_to_address="noreply@paperplane.example.com"
password_env="smtp_password"

[authentication_methods.email]
active = true
method_type = "email"
applied_policies = ["staff_only"]
should_create_new_users = false

[sql]
users_table = "users"
devices_table = "devices"
magiclink_table = "magiclinks"

[policies.staff_only]
active = true
action = "allow"
property = "email"
ends_with = "@oracularhades.com"

[hostname.sydney]
active = true
hostname = "sydney.example.com"
alias = "Sydney"
authentication_methods = ["email"]
multistep_authentication_methods = false
applied_policies = ["staff_only"]
```

# Integration examples
### Guard + NGINX:
```
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  annotations:
    nginx.ingress.kubernetes.io/auth-method: POST
    nginx.ingress.kubernetes.io/auth-url: http://guard-service.guard.svc.cluster.local/api/proxy/authentication
    nginx.ingress.kubernetes.io/error-page: https://guard.example.com/frontend/access-denied
    nginx.ingress.kubernetes.io/auth-signin: https://guard.example.com/frontend/login?redirect=$scheme://$http_host$request_uri
spec:
    [..]
  tls:
  - hosts:
    - guard.example.com
    secretName: guard-example-com-tls
```

# Security
Guard uses [hades-auth](https://github.com/oracularhades/hades-auth) static_auth (which is a signed JWT) stored in cookies and signed with a private key generated by the user's device. It's pratically impossible to bruteforce a signed JWT (which must match a valid deviceid), at least not without setting off alarm bells. This usage of JWTs, signed by the private keys only known to the client, is much more secure than session tokens.

*Note: Yes, [hades-auth](https://github.com/oracularhades/hades-auth) is all about completely signed requests, but that can't be done with Guard, because the static_auth key has to be stored in cookies.*

# Known issues
If you run into an issue, please check https://github.com/oracularhades/guard/issues - and when you do that, (nicely) prod me to fix the issue. If the bug isn't listed, please make a Github issue and I'll fix it.

# What's on the TODO list?
- SSO/SAML authentication. Guard being able to authentication users via those protocols, and be able to be the identity provider for those protocols. Such as if you want to authentication someone on a NAS/router via guard.
- Better error handling in requests.
- Some syntax improvements.
- Cleaning up where functions are stored and adding comments.
- Set a header Guard should tell Rocket (the webserver Guard runs on) to treat as the IP, such as, x-real-ip.
- Ability for Guard to be an app's authentication. Such as authenticating a user, and then proxying all requests, but adding a header identifying the user.
- Implement HCaptcha.
- Magiclink codes need to be hashed / encrypted in the DB.
- Adjustable magiclink expiry.
- Showing account email / ID on access-denied page. Which requires the /user/@me endpoints.

# Feature requests:
I'm happy to add what people need. However, Guard avoids clutter and removes barely used features. It's important to minimize the attack surface. Code we have, is code we have to maintain. Guard aims to be efficient and secure.

https://github.com/oracularhades/guard/discussions/categories/feature-request

# Code guidelines
- Keep functions to <50 lines of code, with small exceptions, excluding code comments. If you go over 50 lines, you should consider if you're doing too much. Read-able code is very important.
- Do not add non-standard/not closely monitored cargo packages. Don't just add a cargo package because you want your terminal output to be colourful. Supply chain attacks exist, and we dont want that.
- Comment your code.

*Actual docs to come soon, this is a description*
